#!/bin/bash
# Bake shell definitions | Spencer Tipping
# Licensed under the terms of the MIT source code license

Introduction.
Shell definitions for the bake build system. This consists of a single
function, 'bake', and a series of internal state variables prefixed with
`__bake_`. Modify these at your peril.

Bake state.
We maintain the rule tables in a few different formats for speed (bash isn't
the most cooperative about data structures). This turns out to be simple enough
because rules have just three pieces:

| 1. Output variable(s).
  2. Input variable(s), some of which are inferred from the command.
  3. Command, which can contain both input and output variables.

Here's how rules are broken down:

| bake %x.o : %x.c :: gcc -c %x.c -o %x.o
       |out|  |in|    |---- command ----|

Expansion involves doing a destructuring bind against the out-vars, then
binding those up and expanding the inputs and commands accordingly.

declare -a __bake_outputs
declare -a __bake_inputs
declare -a __bake_commands

Destructuring binds.
Binding output variables requires us to do a destructuring bind to fill in the
value of any % placeholders. We can do this easily enough by pulling all of the
variables out, then matching against bash shell expansion one by one.

Match semantics aren't completely straightforward. In particular, bake supports
implicit plurality for glob-style values. So, for example, you can write stuff
like this:

| bake %files.c = foo.c bar.c

This will result in %files = foo bar. This works because bake implements a
distributive property of string concatenation and variables:

| bake %var = val0 val1 ... valN
  [pfx]%var[sfx] = [pfx]val0[sfx] [pfx]val1[sfx] ... [pfx]valN[sfx]

Normally bake will stick to just one value per variable (TODO: figure this out)

__bake_parse_vars() {
  # FIXME

  # Returns location of each variable as a pair of numbers (start, length). For
  # example:
  # __bake_parse_vars "foo %bar.c %bif.baz" -> 4 4 11 4
  #                    0123456789012345678
  local str=$1
  local eaten=0

  while [[ $str =~ ^([^%]*)(%\w+)(.*)$ ]]; do
    eaten=$((eaten + ${#BASH_REMATCH[1]}))
    echo $eaten ${#BASH_REMATCH[2]}
    eaten=$((eaten + ${#BASH_REMATCH[2]}))
    str=${BASH_REMATCH[3]}
  done
}

__bake_match() {
  # Destructures the specified string against the template, returning one
  # variable match per line if successful. You should use __bake_parse_vars to
  # get the list of variables corresponding to the matched values.
}
