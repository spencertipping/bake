#!/bin/bash
# Bake function definition | Spencer Tipping
# Licensed under the terms of the MIT source code license

Introduction.
Bake provides a single entry point, the `bake-instance` function. The global
`bake-instance` function is a way to create bake instances, each of which is a
function that operates on a dependency graph. Instances are isolated from each
other. Because of this design, bake ends up compiling a new function each time
you create an instance. Bash doesn't officially support closures, but we can
come close by using eval to compile references to global names.

An instance called "bake" is available to bakefiles. See
[bake-template](./bake-template) for details about how this works.

Bake-instance usage.
Most of the configuration is done after you create an instance; this function
just takes the name of the instance you want to create.

bake-instance() {
local name=$1

if [[ $# != 1 ]]; then
  echo "usage: bake-instance <instance-name>"
  return 1
fi

State definitions.
Every stateful definition in bake is represented as a rule, which has three
parts, or a global, which has one. Here's a rule:

| bake %x.o : %x.c :: gcc -c %in -o %out
       |out|  |in|    |--- command ----|

And here's a global:

| bake %modules.c %others = *

Globals are stored by name in their own variables. For example, the above
definition will create these bindings:

| declare -a __bake_$name_global_modules=(...)
  declare -a __bake_$name_global_others=(...)

Note that because of this indirection, any reference we make to a global
variable will be from dynamically compiled code.

You can't combine globals with locals. For example, you can't write this:

| bake %modules.%ext = *.%ext           # invalid

The reason is that this definition wouldn't give a value to `%modules`; it
would just make `%modules` a part of another rewriting rule (and somewhat
counterintuitively, a literal). The rule is that the right-hand side of any
global assignment must be fully-specified at definition time.

Like grounded rules, ungrounded rules can have commands:

| bake inputs-for-%x.o = %x.c %x.h :: echo "hi"
       |---- out ----|   |- in --|    |command|

Note that bake assumes that any command attached to an ungrounded edge is cheap
to execute. As such, these commands are not parallelized and ungrounded edges
are executed speculatively.

As a special case, any variable that is bound but not referenced becomes
global. This is why you can do things like this:

| bake %xs.c %others = *                # bash expands the *
  bake --echo %xs %others

Bake lets you throw away pieces of a binding form without creating a global by
using *, which will match text but won't bind it to anything. (In fact, any
other bash glob-matching stuff is also fair game.)

eval "
# Grounded rules
declare -a __bake_${name}_g_out
declare -a __bake_${name}_g_in
declare -a __bake_${name}_g_commands

# Ungrounded rules
declare -a __bake_${name}_u_out
declare -a __bake_${name}_u_in
declare -a __bake_${name}_u_commands
"

}
