#!/bin/bash
# Bake function definition | Spencer Tipping
# Licensed under the terms of the MIT source code license

Introduction.
Bake provides a single entry point, the `bake-instance` function. The global
`bake-instance` function is a way to create bake instances, each of which is a
function that operates on a dependency graph. Instances are isolated from each
other. Because of this design, bake ends up compiling a new function each time
you create an instance. Bash doesn't officially support closures, but we can
come close by using eval to compile references to global names.

An instance called "bake" is available to bakefiles. See
[bake-template](./bake-template) for details about how this works.

Bake-instance usage.
Most of the configuration is done after you create an instance; this function
just takes the name of the instance you want to create.

bake-instance() {
local name=$1
local prefix=__bake_$name

if [[ $# != 1 ]]; then
  echo "usage: bake-instance <instance-name>"
  return 1
fi

State definitions.
Every stateful definition in bake is represented as a rule, which has three
parts, or a global, which has one. Here's a rule:

| bake %x.o : %x.c :: gcc -c %in -o %out
       |out|  |in|    |--- command ----|

And here's a global:

| bake %modules.c %others = *

Globals are stored by name in their own variables. For example, the above
definition will create these bindings:

| declare -a __bake_$name_global_modules=(...)
  declare -a __bake_$name_global_others=(...)

Note that because of this indirection, any reference we make to a global
variable will be from dynamically compiled code.

You can't combine globals with locals. For example, you can't write this:

| bake %modules.%ext = *.%ext           # invalid

The reason is that this definition wouldn't give a value to `%modules`; it
would just make `%modules` a part of another rewriting rule (and somewhat
counterintuitively, a literal). The rule is that the right-hand side of any
global assignment must be fully-specified at definition time.

Like grounded rules, ungrounded rules can have commands:

| bake inputs-for-%x.o = %x.c %x.h :: echo "hi"
       |---- out ----|   |- in --|    |command|

Note that bake assumes that any command attached to an ungrounded edge is cheap
to execute. As such, these commands are not parallelized and ungrounded edges
are executed speculatively and possibly multiple times.

eval "
# Grounded rules
declare -a ${prefix}_g_out
declare -a ${prefix}_g_in
declare -a ${prefix}_g_commands

# Ungrounded rules
declare -a ${prefix}_u_out
declare -a ${prefix}_u_in
declare -a ${prefix}_u_commands

# List of globals (so we can print them later)
declare -a ${prefix}_globals

# Configuration
declare ${prefix}_exit_with=exit
declare ${prefix}_backend=bake-backend-sha
declare -a ${prefix}_init
declare -a ${prefix}_finalize

# Inspection functions
${prefix}_print_rules() {
  local i
  for (( i = 0; i < \${#${prefix}_g_out[@]}; ++i )); do
    echo \${${prefix}_g_out[\$i]} : \\
         \${${prefix}_g_in[\$i]} :: \\
         \${${prefix}_g_command[\$i]}
  done

  for (( i = 0; i < \${#${prefix}_u_out[@]}; ++i )); do
    echo \${${prefix}_u_out[\$i]} = \\
         \${${prefix}_u_in[\$i]} :: \\
         \${${prefix}_u_command[\$i]}
  done
}

${prefix}_print_globals() {
  local g
  for g in \"\${${prefix}_globals[@]}\"; do
    echo -n %\$g =
    eval \"echo \\\${${prefix}_global_\$g[@]}\"
  done
}
"

Variable handling logic.
Code to bind and expand expressions with variables. This is optimized in some
small ways by doing things like using bash wildcard matching as a preliminary
check.



}
